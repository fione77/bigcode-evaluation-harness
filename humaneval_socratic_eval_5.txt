================================================================================
PROBLEM 1
Prompt:
from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """ Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    """


Generated code:
def find_pattern(text: str, pattern: str) -> int:
    """
    Finds the starting index of the pattern in the text using the KMP algorithm.

    Args:
        text (str): The text to search in.
        pattern (str): The pattern to search for.

    Returns:
        int: The starting index of the pattern in the text, or -1 if not found.

    Raises:
        ValueError: If the input strings are null or empty.
    """
    # Validate input strings
    if not text or not pattern:
        raise ValueError("Null or empty input strings are not allowed")

    # Handle edge cases
    if not pattern:
        return 0
    if len(pattern) > len(text):
        return -1

    # Compute prefix function
    prefix = compute_prefix_function(pattern)

    # Perform KMP search
    return kmp_search(text, pattern, prefix)


def compute_prefix_function(pattern: str) -> list:
    """
    Computes the prefix function used in the KMP algorithm.

    Args:
        pattern (str): The pattern to compute the prefix function for.

    Returns:
        list: The prefix function.
    """
    # Initialize prefix function
    prefix = [0] * len(pattern)
    j = 0

    # Compute prefix function
    for i in range(1, len(pattern)):
        # If the current character does not match, move to the previous prefix
        while j > 0 and pattern[i] != pattern[j]:
            j = prefix[j - 1]
        # If the current character matches, increment the prefix
        if pattern[i] == pattern[j]:
            j += 1
        # Update the prefix function
        prefix[i] = j

    return prefix


def kmp_search(text: str, pattern: str, prefix: list) -> int:
    """
    Performs the KMP search on the text using the prefix function.

    Args:
        text (str): The text to search in.
        pattern (str): The pattern to search for.
        prefix (list): The prefix function.

    Returns:
        int: The starting index of the pattern in the text, or -1 if not found.
    """
    j = 0

    # Perform KMP search
    for i in range(len(text)):
        # If the current character does not match, move to the previous prefix
        while j > 0 and text[i] != pattern[j]:
            j = prefix[j - 1]
        # If the current character matches, increment the prefix
        if text[i] == pattern[j]:
            j += 1
        # If the pattern is found, return the starting index
        if j == len(pattern):
            return i - len(pattern) + 1

    # If the pattern is not found, return -1
    return -1


# Example usage
if __name__ == "__main__":
    text = "abcabcabc"
    pattern = "abc"
    index = find_pattern(text, pattern)
    print(f"Pattern '{pattern}' found at index {index} in text '{text}'")

Evaluation result:
✅ All tests passed
================================================================================

================================================================================
PROBLEM 2
Prompt:
from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """ Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    ['()', '(())', '(()())']
    """


Generated code:
def find_pattern(text: str, pattern: str) -> list[int]:
    """
    Find all occurrences of a pattern within a given text.

    Args:
    text (str): The input text.
    pattern (str): The pattern to search for.

    Returns:
    list[int]: A list of indices where the pattern starts in the text.

    Raises:
    TypeError: If input is not a string.
    ValueError: If pattern is empty or longer than the text.
    """
    if not isinstance(text, str) or not isinstance(pattern, str):
        raise TypeError("Input must be strings")
    
    if not pattern:
        raise ValueError("Pattern cannot be empty")
    
    if len(pattern) > len(text):
        return []
    
    prefix = compute_prefix_function(pattern)
    indices = []
    text_index = 0
    pattern_index = 0
    
    # Iterate through the text, using the prefix function to determine how many characters can be safely skipped when a mismatch occurs.
    while text_index < len(text):
        # If the current characters in the text and pattern match, move to the next characters in both.
        if pattern[pattern_index] == text[text_index]:
            pattern_index += 1
            text_index += 1
            # If the entire pattern has been matched, add the starting index to the list of indices and reset the pattern index.
            if pattern_index == len(pattern):
                indices.append(text_index - len(pattern))
                pattern_index = prefix[pattern_index - 1]
        # If the current characters do not match and the pattern index is not at the start, reset the pattern index using the prefix function.
        elif pattern_index != 0:
            pattern_index = prefix[pattern_index - 1]
        # If the current characters do not match and the pattern index is at the start, move to the next character in the text.
        else:
            text_index += 1
    
    return indices

def compute_prefix_function(pattern: str) -> list[int]:
    """
    Compute the prefix function used in the KMP algorithm.

    Args:
    pattern (str): The pattern to compute the prefix function for.

    Returns:
    list[int]: A list of prefix function values.
    """
    if len(pattern) == 1:
        return [0]
    
    prefix = [0] * len(pattern)
    j = 0
    
    # Iterate through the pattern to compute the prefix function values.
    for i in range(1, len(pattern)):
        # If the current character does not match the character at the current prefix index, reset the prefix index.
        while j > 0 and pattern[i] != pattern[j]:
            j = prefix[j - 1]
        # If the current character matches the character at the current prefix index, increment the prefix index.
        if pattern[i] == pattern[j]:
            j += 1
        # Store the prefix function value for the current character.
        prefix[i] = j
    
    return prefix

import unittest

class TestStringMatchingAlgorithm(unittest.TestCase):
    def test_empty_pattern(self):
        with self.assertRaises(ValueError):
            find_pattern("hello", "")

    def test_pattern_longer_than_text(self):
        self.assertEqual(find_pattern("hello", "hello world"), [])

    def test_pattern_found(self):
        self.assertEqual(find_pattern("hello world", "world"), [6])

    def test_pattern_not_found(self):
        self.assertEqual(find_pattern("hello world", "foo"), [])

    def test_multiple_occurrences(self):
        self.assertEqual(find_pattern("hello world hello", "hello"), [0, 12])

    def test_input_validation(self):
        with self.assertRaises(TypeError):
            find_pattern(123, "hello")

if __name__ == "__main__":
    unittest.main()

Evaluation result:
✅ All tests passed
================================================================================

================================================================================
PROBLEM 3
Prompt:


def truncate_number(number: float) -> float:
    """ Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.
    >>> truncate_number(3.5)
    0.5
    """


Generated code:
def handleEdgeCases(arr: list[int], size: int) -> int:
    """
    Checks for edge cases such as an empty array or an array with all negative numbers.

    Args:
        arr (list[int]): A one-dimensional array of integers.
        size (int): The size of the array.

    Returns:
        int: The maximum sum of a subarray in the edge case.
    """
    # Check for empty array
    if size == 0:
        return 0

    # Check for array with a single element
    if size == 1:
        return arr[0]

    # Check for array with all negative numbers
    if all(num < 0 for num in arr):
        return max(arr)

    return None


def kadaneAlgorithm(arr: list[int], size: int) -> int:
    """
    Implements Kadane's algorithm to find the maximum sum of a subarray.

    Args:
        arr (list[int]): A one-dimensional array of integers.
        size (int): The size of the array.

    Returns:
        int: The maximum sum of a subarray.
    """
    # Initialize maxSum to the smallest possible integer value
    maxSum = float('-inf')
    currentSum = 0

    # Iterate through the array
    for num in arr:
        # Update currentSum
        currentSum = max(num, currentSum + num)

        # Update maxSum if a larger sum is found
        maxSum = max(maxSum, currentSum)

    return maxSum


def maxSubarraySum(arr: list[int], size: int) -> int:
    """
    Finds the maximum sum of a subarray in the given array.

    Args:
        arr (list[int]): A one-dimensional array of integers.
        size (int): The size of the array.

    Returns:
        int: The maximum sum of a subarray.

    Raises:
        ValueError: If the input array is not a list or if the size is not an integer.
        TypeError: If the input array contains non-integer values.
    """
    # Input validation
    if not isinstance(arr, list):
        raise ValueError("Input array must be a list.")
    if not isinstance(size, int):
        raise ValueError("Size must be an integer.")
    if not all(isinstance(num, int) for num in arr):
        raise TypeError("Input array must contain only integers.")
    if size != len(arr):
        raise ValueError("Size must match the length of the input array.")

    # Check for edge cases
    edgeCaseResult = handleEdgeCases(arr, size)
    if edgeCaseResult is not None:
        return edgeCaseResult

    # Find the maximum sum of a subarray using Kadane's algorithm
    maxSum = kadaneAlgorithm(arr, size)

    return maxSum


# Example usage
if __name__ == "__main__":
    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
    size = len(arr)
    result = maxSubarraySum(arr, size)
    print(f"Maximum subarray sum: {result}")

Evaluation result:
✅ All tests passed
================================================================================

================================================================================
PROBLEM 4
Prompt:
from typing import List


def below_zero(operations: List[int]) -> bool:
    """ You're given a list of deposit and withdrawal operations on a bank account that starts with
    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    at that point function should return True. Otherwise it should return False.
    >>> below_zero([1, 2, 3])
    False
    >>> below_zero([1, 2, -4, 5])
    True
    """


Generated code:
import heapq
from typing import Dict, List, Tuple

class PriorityQueue:
    """Priority queue implementation using a binary heap."""
    
    def __init__(self):
        self._queue = []
        self._index = 0

    def enqueue(self, node: str, distance: int):
        """Add a node to the priority queue."""
        heapq.heappush(self._queue, (distance, self._index, node))
        self._index += 1

    def dequeue(self) -> Tuple[int, str]:
        """Remove and return the node with the minimum distance."""
        if self.is_empty():
            raise IndexError("Priority queue is empty")
        return heapq.heappop(self._queue)[0], heapq.heappop(self._queue)[2]

    def is_empty(self) -> bool:
        """Check if the priority queue is empty."""
        return len(self._queue) == 0


def initialize_distances(graph: Dict[str, List[Tuple[str, int]]], source: str) -> Dict[str, int]:
    """
    Initialize distances to all nodes as infinity except for the source node, which is set to 0.

    Args:
    graph: The weighted graph represented as an adjacency list.
    source: The source node.

    Returns:
    A dictionary mapping each node to its current shortest distance from the source.
    """
    distances = {node: float('inf') for node in graph}
    distances[source] = 0
    return distances


def extract_min_distance_node(distances: Dict[str, int]) -> str:
    """
    Find the node with the minimum distance that has not been processed.

    Args:
    distances: A dictionary mapping each node to its current shortest distance from the source.

    Returns:
    The node with the minimum distance.
    """
    return min(distances, key=distances.get)


def update_distances(graph: Dict[str, List[Tuple[str, int]]], distances: Dict[str, int], current_node: str, previous_nodes: Dict[str, str], queue: PriorityQueue) -> None:
    """
    Update distances of neighboring nodes if a shorter path is found through the current node.

    Args:
    graph: The weighted graph represented as an adjacency list.
    distances: A dictionary mapping each node to its current shortest distance from the source.
    current_node: The current node being processed.
    previous_nodes: A dictionary to keep track of the previous node in the shortest path.
    queue: The priority queue.
    """
    for neighbor, weight in graph[current_node]:
        distance = distances[current_node] + weight
        if distance < distances[neighbor]:
            distances[neighbor] = distance
            previous_nodes[neighbor] = current_node
            queue.enqueue(neighbor, distance)


def shortest_path(graph: Dict[str, List[Tuple[str, int]]], source: str, destination: str) -> List[str]:
    """
    Find the shortest path between the source and destination nodes in the weighted graph.

    Args:
    graph: The weighted graph represented as an adjacency list.
    source: The source node.
    destination: The destination node.

    Returns:
    A list of nodes representing the shortest path from the source to the destination.

    Raises:
    ValueError: If the graph is empty or the source/destination node does not exist.
    """
    if not graph:
        raise ValueError("Graph is empty")
    if source not in graph or destination not in graph:
        raise ValueError("Source or destination node does not exist")

    distances = initialize_distances(graph, source)
    previous_nodes = {}
    queue = PriorityQueue()
    queue.enqueue(source, 0)

    while not queue.is_empty():
        try:
            current_distance, current_node = queue.dequeue()
        except IndexError:
            break

        if current_node == destination:
            path = []
            while current_node is not None:
                path.append(current_node)
                current_node = previous_nodes.get(current_node)
            return path[::-1]

        update_distances(graph, distances, current_node, previous_nodes, queue)

    return []


# Test cases
if __name__ == "__main__":
    # Test case 1: Empty graph
    try:
        shortest_path({}, "A", "B")
    except ValueError as e:
        print(e)

    # Test case 2: Non-existent source/destination node
    try:
        shortest_path({"A": []}, "B", "C")
    except ValueError as e:
        print(e)

    # Test case 3: Single node graph
    print(shortest_path({"A": []}, "A", "A"))  # Expected output: ["A"]

    # Test case 4: Disconnected graph
    print(shortest_path({"A": [("B", 1)], "C": [("D", 1)]}, "A", "D"))  # Expected output: []

    # Test case 5: Graph with negative weight edges
    print(shortest_path({"A": [("B", -1)], "B": [("C", 1)]}, "A", "C"))  # Expected output: ["A", "B", "C"]

    # Test case 6: Normal graph with positive weight edges
    print(shortest_path({"A": [("B", 1), ("C", 3)], "B": [("C", 2)]}, "A", "C"))  # Expected output: ["A", "B", "C"]

Evaluation result:
❌ Some tests failed
Traceback (most recent call last):
  File "/workspaces/bigcode-evaluation-harness/humaneval_socratic_Eval.py", line 24, in safe_exec
    exec(code, {}, local_env)
  File "<string>", line 4, in <module>
  File "<string>", line 16, in PriorityQueue
NameError: name 'Tuple' is not defined. Did you mean: 'tuple'?

================================================================================

================================================================================
PROBLEM 5
Prompt:
from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """ For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """


Generated code:
def handleEdgeCases(arr: list[int], n: int) -> int:
    """
    This function handles edge cases such as an empty array or an array with all negative numbers.

    Args:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    arr (list): A list of integers.
        n (int): The size of the array.

    Returns:
        int: The maximum sum of a subarray.

    Raises:
        ValueError: If the input array is empty.
    """
    if n == 0:
        raise ValueError("Input array is empty")
    if all(num < 0 for num in arr):
        return max(arr)
    if n == 1:
        return arr[0]
    return None


def kadaneAlgorithm(arr: list[int], n: int) -> int:
    """
    This function implements Kadane's algorithm to find the maximum sum of a subarray.

    Args:
        arr (list): A list of integers.
        n (int): The size of the array.

    Returns:
        int: The maximum sum of a subarray.
    """
    max_sum = float('-inf')
    current_sum = 0

    for num in arr:
        # Update current_sum to be the maximum of the current element and the sum of the current element and the previous current_sum
        current_sum = max(num, current_sum + num)
        # Update max_sum to be the maximum of the current max_sum and current_sum
        max_sum = max(max_sum, current_sum)

    return max_sum


def maxSubarraySum(arr: list[int], n: int) -> int:
    """
    This function calculates the maximum sum of a subarray within a given array of integers.

    Args:
        arr (list): A list of integers.
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    n (int): The size of the array.

    Returns:
        int: The maximum sum of a subarray.

    Raises:
        ValueError: If the input array is empty.
    """
    # Check if the input array is empty
    if not arr:
        raise ValueError("Input array is empty")

    # Handle edge cases
    edge_case_result = handleEdgeCases(arr, n)
    if edge_case_result is not None:
        return edge_case_result

    # Initialize max_sum and current_sum to the first element of the array
    max_sum = arr[0]
    current_sum = arr[0]

    # Iterate through the array from the second element to the end
    for i in range(1, n):
        # Update current_sum to be the maximum of the current element and the sum of the current element and the previous current_sum
        current_sum = max(arr[i], current_sum + arr[i])
        # Update max_sum to be the maximum of the current max_sum and current_sum
        max_sum = max(max_sum, current_sum)

    return max_sum


import unittest


class TestMaxSubarraySum(unittest.TestCase):
    def test_empty_array(self):
        with self.assertRaises(ValueError):
            maxSubarraySum([], 0)

    def test_single_element_array(self):
        self.assertEqual(maxSubarraySum([5], 1), 5)

    def test_all_negative_numbers(self):
        self.assertEqual(maxSubarraySum([-1, -2, -3], 3), -1)

    def test_max_subarray_sum(self):
        self.assertEqual(maxSubarraySum([-2, -3, 4, -1, -2, 1, 5, -3], 8), 7)


if __name__ == '__main__':
    unittest.main()

Evaluation result:
✅ All tests passed
================================================================================

